using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading.Tasks;
using DSharpPlus.CommandsNext;
using DSharpPlus.CommandsNext.Attributes;
using DSharpPlus.Entities;
using log4net;

namespace Negri.Wot.Bot
{
    [SuppressMessage("ReSharper", "UnusedMember.Global")]
    public class GameCommands : CommandsBase
    {
        private static readonly ILog Log = LogManager.GetLogger(typeof(GameCommands));

        private static readonly Random Rand = new Random();

        [Command("random")]
        [Description("Returns a random integer number.")]
        public async Task Random(CommandContext ctx, [Description("Minimum, inclusive.")] int min = 1,
            [Description("Maximum, inclusive.")] int max = 6)
        {
            if (!await CanExecute(ctx, Features.Games))
            {
                return;
            }

            await ctx.RespondAsync("", embed: GetTheEndMessage());

            Log.Debug($"Requesting {nameof(Random)}({min}, {max})...");

            var number = Rand.Next(min, max + 1);
            await ctx.RespondAsync($"🎲 {ctx.User.Mention}, your random number between {min} and {max} is: {number}");
        }

        [Command("dice")]
        [Description("Rolls a dice.")]
        public async Task Dice(CommandContext ctx, [Description("Sides on the dice.")] int sides = 6)
        {
            if (!await CanExecute(ctx, Features.Games))
            {
                return;
            }

            await ctx.RespondAsync("", embed: GetTheEndMessage());

            Log.Debug($"Requesting {nameof(Dice)}({sides})...");

            var number = Rand.Next(1, sides + 1);
            await ctx.RespondAsync($"🎲 {ctx.User.Mention}, your dice rolled {number}");
        }

        [Command("coin")]
        [Aliases("flip")]
        [Description("Flip a coin.")]
        public async Task Coin(CommandContext ctx)
        {
            if (!await CanExecute(ctx, Features.Games))
            {
                return;
            }

            await ctx.RespondAsync("", embed: GetTheEndMessage());

            Log.Debug($"Requesting {nameof(Coin)}()...");

            var cfg = GuildConfiguration.FromGuild(ctx.Guild);

            var isHead = Rand.Next(0, 2) == 0;

            var embed = new DiscordEmbedBuilder
            {
                Title = isHead ? "Head!" : "Tail!",
                Description = $"{ctx.User.Mention}, your coin flipped {(isHead ? "**Head**" : "**Tail**")}!",
                Color = DiscordColor.Goldenrod,
                Url = BasicExtensions.SiteUrl(),
                ImageUrl = BasicExtensions.SiteUrl() + $"/images/coin-{(isHead ? "head" : "tail")}.png",
                Author = new DiscordEmbedBuilder.EmbedAuthor
                {
                    Name = "WoTClans",
                    Url = BasicExtensions.SiteUrl()
                },
                Footer = new DiscordEmbedBuilder.EmbedFooter
                {
                    Text = $"Flipped at {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC."
                }
            };

            Log.Debug($"Returned {nameof(Coin)}() = {isHead}");

            await ctx.RespondAsync("", embed: embed);
        }

        #region Timers

        private readonly object _timerLock = new object();

        private readonly Dictionary<ulong, RunningTimer> _timers = new Dictionary<ulong, RunningTimer>();

        private class RunningTimer
        {
            public ulong UserId { get; set; }

            public DateTime Start { private get; set; }

            public int Duration { private get; set; }

            public DateTime End => Start.AddSeconds(Duration);
        }

        private bool AddTimer(ulong userId, DateTime start, int duration)
        {
            lock (_timerLock)
            {
                if (_timers.ContainsKey(userId))
                {
                    return false;
                }

                _timers.Add(userId, new RunningTimer {UserId = userId, Start = start, Duration = duration});
                return true;
            }
        }

        private bool RemoveTimer(ulong userId)
        {
            lock (_timerLock)
            {
                return _timers.Remove(userId);
            }
        }

        private bool HasTimer(ulong userId)
        {
            lock (_timerLock)
            {
                return _timers.ContainsKey(userId);
            }
        }

        private void PruneTimers()
        {
            lock (_timerLock)
            {
                var dead = _timers.Values.Where(t => DateTime.UtcNow > t.End).Select(t => t.UserId).ToList();
                if (!dead.Any())
                {
                    return;
                }

                foreach (var userId in dead)
                {
                    _timers.Remove(userId);
                }
            }
        }

        [Description("Kill a timer that you started.")]
        [Command("kill")]
        public async Task Kill(CommandContext ctx)
        {
            if (!await CanExecute(ctx, Features.Games))
            {
                return;
            }

            Log.Debug($"Requesting {nameof(Kill)}()...");

            await ctx.TriggerTypingAsync();

            var removed = RemoveTimer(ctx.User.Id);
            if (removed)
            {
                await ctx.RespondAsync($"{ctx.User.Mention}, a HEAT shell was sent for your timer...");
            }
            else
            {
                await ctx.RespondAsync($"{ctx.User.Mention}, you don't have any running timers.");
            }
        }


        [Description("Starts a timer on the range of 30s up to 5min.")]
        [Command("timer")]
        public async Task Timer(CommandContext ctx, [Description("Minutes (up to 5), or Seconds (from 15 to 300")]
            int minutesOrSeconds)
        {
            if (!await CanExecute(ctx, Features.Games))
            {
                return;
            }

            await ctx.RespondAsync("", embed: GetTheEndMessage());

            Log.Debug($"Requesting {nameof(Timer)}({minutesOrSeconds})...");

            await ctx.TriggerTypingAsync();

            int seconds;
            if (minutesOrSeconds <= 5)
            {
                seconds = minutesOrSeconds * 60;
            }
            else
            {
                seconds = minutesOrSeconds;
            }

            if (seconds > 5 * 60)
            {
                await ctx.RespondAsync($"{ctx.User.Mention}, the maximum timer interval is 5 minutes.");
                return;
            }

            if (seconds < 15)
            {
                await ctx.RespondAsync($"{ctx.User.Mention}, the minimum timer interval is 30 seconds.");
                return;
            }

            var start = DateTime.UtcNow;
            if (!AddTimer(ctx.User.Id, start, seconds))
            {
                await ctx.RespondAsync(
                    $"{ctx.User.Mention}, you already have a timer running. Wait for it finish, or `kill` the timer.");
                return;
            }

            await ctx.RespondAsync($"{ctx.User.Mention}, starting a timer of {seconds}s...");

            var lastAlert = 0;
            var end = DateTime.UtcNow.AddSeconds(seconds);
            while (end > DateTime.UtcNow)
            {
                Task.Delay(TimeSpan.FromMilliseconds(250)).Wait();
                var remaining = end - DateTime.UtcNow;
                var remainingSeconds = (int) remaining.TotalSeconds;
                if (remainingSeconds % 10 == 0 && lastAlert != remainingSeconds)
                {
                    if (!HasTimer(ctx.User.Id))
                    {
                        await ctx.RespondAsync(
                            $"{ctx.User.Mention}, your timer, with {remainingSeconds}s remaining, was killed... RIP.");
                        return;
                    }

                    if (remainingSeconds >= 60 && remainingSeconds % 30 == 0)
                    {
                        await ctx.RespondAsync($"{remainingSeconds}s remaining, {ctx.User.Mention}...");
                        lastAlert = remainingSeconds;
                    }
                    else if (remainingSeconds >= 5 && remainingSeconds < 60 && remainingSeconds % 10 == 0)
                    {
                        await ctx.RespondAsync($"{remainingSeconds}s remaining, {ctx.User.Mention}...");
                        await ctx.TriggerTypingAsync();
                        lastAlert = remainingSeconds;
                    }
                }
            }

            await ctx.RespondAsync($"🏁 Time is up, {ctx.User.Mention}!");

            PruneTimers();
        }

        #endregion
    }
}